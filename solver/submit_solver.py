import json
import base64
from urllib.parse import urljoin, urlparse
import requests

DEFAULT_TIMEOUT = 20

def make_payload(email: str, secret: str, url: str, answer):
    return {
        "email": email,
        "secret": secret,
        "url": url,
        "answer": answer
    }

def normalize_submit_url(submit_url: str, page_url: str = None):
    """
    If submit_url is relative, join with page_url (if provided).
    """
    if not submit_url:
        return None
    # If it's like '/submit' or similar relative path and page_url supplied, join it.
    try:
        parsed = urlparse(submit_url)
        if parsed.scheme and parsed.netloc:
            return submit_url
        if page_url:
            return urljoin(page_url, submit_url)
    except Exception:
        pass
    return submit_url

def post_json(submit_url: str, payload: dict, headers: dict = None, timeout: int = DEFAULT_TIMEOUT):
    """
    POST the payload as application/json. Returns a tuple (ok, status_code, resp_json_or_text).
    """
    headers = headers or {"Content-Type": "application/json"}
    try:
        resp = requests.post(submit_url, json=payload, headers=headers, timeout=timeout)
        text = resp.text
        try:
            data = resp.json()
        except Exception:
            data = text
        return True, resp.status_code, data
    except requests.exceptions.RequestException as e:
        return False, None, str(e)

def auto_determine_answer(scraped: dict):
    """
    Heuristic to determine an answer from scraped content.
    For the demo page the question often says "answer: anything you want" or asks to POST anything.
    We'll return a safe default that can be later replaced by other solvers.
    """
    text = (scraped.get("question_text") or "") or ""
    # If there's a sample JSON snippet with "answer": "something" we can try to parse it
    # but simplest safe behavior:
    if "answer" in text.lower():
        return "auto-answer: submit detected"
    # fallback
    return "auto-answer: generated by solver"

def submit_quiz(scraped: dict, email: str, secret: str, page_url: str = None, try_now: bool = True):
    """
    Main helper to submit an answer when a submit task is detected.

    scraped: dict returned by your scraper (question_text, file_links, submit_url)
    email, secret: credentials to include in payload
    page_url: original page url (used when submit_url is relative)
    try_now: if True, attempt the HTTP POST immediately; otherwise just return prepared payload and url

    Returns:
      {
        "submit_url": final_submit_url_or_none,
        "payload": payload,
        "posted": True/False/None,
        "status_code": int or None,
        "response": parsed response or error str
      }
    """
    submit_url_raw = scraped.get("submit_url")
    final_submit_url = normalize_submit_url(submit_url_raw, page_url)
    answer = auto_determine_answer(scraped)
    payload = make_payload(email, secret, page_url, answer)

    if not try_now or not final_submit_url:
        return {
            "submit_url": final_submit_url,
            "payload": payload,
            "posted": None,
            "status_code": None,
            "response": "Not posted (missing URL or try_now=False)"
        }

    ok, status, resp = post_json(final_submit_url, payload)
    return {
        "submit_url": final_submit_url,
        "payload": payload,
        "posted": ok,
        "status_code": status,
        "response": resp
    }

def attach_file_as_base64(file_bytes: bytes, filename: str):
    """
    Utility: convert a file's bytes to a base64 data URI that can be embedded into JSON answer fields.
    Example usage if a quiz expects a file upload in base64 form.
    """
    b64 = base64.b64encode(file_bytes).decode("ascii")
    # content type not knownâ€”use octet-stream or allow caller to modify
    return f"data:application/octet-stream;name={filename};base64,{b64}"
